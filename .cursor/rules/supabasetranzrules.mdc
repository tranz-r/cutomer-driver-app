---
description:
globs:
alwaysApply: true
---

# RBAC Implementation Rule for Customer Driver App

## OVERVIEW
This rule defines the step-by-step implementation plan for Supabase RBAC with .NET backend integration. Follow phases sequentially and DO NOT proceed to next phase until current phase is 100% complete and tested.

## ARCHITECTURE PRINCIPLES
- READ operations: Direct Supabase client (fast, JWT claims)
- WRITE operations: .NET backend API (secure, service role)
- User roles: customer, driver, commercial_client, admin
- Auth methods: Email/Password, OTP, Social (Google, Facebook, Apple)

## PHASE IMPLEMENTATION ORDER

### PHASE 1: Database Foundation + .NET API Spec
**GOAL**: Set up RBAC schema and define API contracts
**FILES TO MODIFY**: None (database + documentation only)

#### Database Setup (Supabase SQL Editor):
```sql
-- Create role and permission enums
CREATE TYPE public.app_role AS ENUM ('customer', 'driver', 'commercial_client', 'admin');
CREATE TYPE public.app_permission AS ENUM (
  'bookings.read', 'bookings.write', 'bookings.delete',
  'jobs.accept', 'jobs.update_status', 'routes.view',
  'users.read', 'users.write', 'analytics.read'
);

-- Create user_roles table
CREATE TABLE public.user_roles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  role app_role NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE (user_id, role)
);

-- Create role_permissions table
CREATE TABLE public.role_permissions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role app_role NOT NULL,
  permission app_permission NOT NULL,
  UNIQUE (role, permission)
);
```

#### .NET API Endpoints (Document Only):
```
POST /api/v1/auth/role
- Body: { userId: string, role: string }
- Auth: JWT Bearer
- Returns: { success: boolean, message: string }
```

**SUCCESS CRITERIA**: 
- ✅ Database tables created
- ✅ Test data inserted manually
- ✅ API specification documented
- ✅ Existing app still works

### PHASE 2: JWT Claims Integration
**GOAL**: Add role claims to JWT tokens
**FILES TO MODIFY**: None (database functions only)

#### Auth Hook Function (Supabase SQL Editor):
Follow this stripe documentation strictly: https://supabase.com/docs/guides/database/postgres/custom-claims-and-role-based-access-control-rbac
```sql
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  claims jsonb;
  user_role public.app_role;
BEGIN
  SELECT role INTO user_role FROM public.user_roles WHERE user_id = (event->>'user_id')::uuid;
  claims := event->'claims';
  
  IF user_role IS NOT NULL THEN
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
  ELSE
    claims := jsonb_set(claims, '{user_role}', 'null');
  END IF;
  
  event := jsonb_set(event, '{claims}', claims);
  RETURN event;
END;
$$;

-- Grant permissions
GRANT usage ON schema public TO supabase_auth_admin;
GRANT execute ON function public.custom_access_token_hook TO supabase_auth_admin;
```

**SUCCESS CRITERIA**:
- ✅ Auth hook enabled in Supabase dashboard
- ✅ JWT tokens contain user_role claim
- ✅ Existing app authentication still works

### PHASE 3: .NET Backend Implementation
**GOAL**: Build and deploy .NET API
**FILES TO MODIFY**: .NET project files only

#### Required .NET Endpoints:
- Implement user role assignment with Supabase service role
- Add proper error handling and validation
- Include audit logging
- Test independently with Postman

**SUCCESS CRITERIA**:
- ✅ .NET API deployed and accessible
- ✅ Role assignment tested via Postman
- ✅ JWT claims update after role assignment
- ✅ Proper error responses

### PHASE 4: Hybrid Client Library
**GOAL**: Create client service combining Supabase + .NET
**FILES TO CREATE**: `lib/hybrid-rbac.ts`

```typescript
import { supabase } from './supabase';
import { jwtDecode } from 'jwt-decode';

export type AppRole = 'customer' | 'driver' | 'commercial_client' | 'admin';

interface JWTPayload {
  user_role?: AppRole;
  [key: string]: any;
}

// READ operations (fast, direct Supabase)
export async function getUserRole(): Promise<AppRole | null> {
  try {
    const { data } = await supabase.auth.getSession();
    if (!data?.session?.access_token) return null;
    
    const jwt = jwtDecode<JWTPayload>(data.session.access_token);
    return jwt.user_role || null;
  } catch (error) {
    console.error('Error decoding JWT:', error);
    return null;
  }
}

// WRITE operations (secure, via .NET API)
export async function assignUserRole(userId: string, role: AppRole): Promise<boolean> {
  try {
    const response = await fetch(`${process.env.EXPO_PUBLIC_DOTNET_API_URL}/api/users/assign-role`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.EXPO_PUBLIC_DOTNET_API_KEY}`,
      },
      body: JSON.stringify({ userId, role }),
    });
    
    const result = await response.json();
    return result.success;
  } catch (error) {
    console.error('Error assigning role:', error);
    return false;
  }
}
```

**SUCCESS CRITERIA**:
- ✅ Library functions work independently
- ✅ JWT decoding tested
- ✅ .NET API calls tested
- ✅ Error handling verified

### PHASE 5: User Intent Capture UI
**GOAL**: Create role selection components
**FILES TO CREATE**: `app/components/UserTypeModal.tsx`

```typescript
interface UserTypeModalProps {
  visible: boolean;
  onClose: () => void;
  onSelectUserType: (role: AppRole) => void;
}

export default function UserTypeModal({ visible, onClose, onSelectUserType }: UserTypeModalProps) {
  // Create clean modal with Customer/Driver/Commercial Client options
  // NO admin option for users
  // Match app theme and design
}
```

**SUCCESS CRITERIA**:
- ✅ Modal UI complete and themed
- ✅ Role selection works
- ✅ No integration yet (standalone component)


### PHASE 6: OTP Integration
**GOAL**: Extend RBAC to OTP auth
**FILES TO MODIFY**: `app/(auth)/otp-send.tsx`, `app/(auth)/otp-verify.tsx`

**SUCCESS CRITERIA**:
- ✅ OTP signup with role selection
- ✅ OTP login with role checking
- ✅ Same .NET integration as email

### PHASE 7: Social Auth Integration
**GOAL**: Complete RBAC with Google auth
**FILES TO MODIFY**: `app/components/GoogleAuth.tsx`

#### Social Auth Flow:
```typescript
// 1. Social authentication (e.g Google, Facebook, Apple)
// 2. Check getUserRole() from JWT
// 3. If no role for user -> show UserTypeModal -> assignUserRole() -> Refresh Session with JWT
// 4. Navigate to appropriate dashboard
```

**SUCCESS CRITERIA**:
- ✅ Google auth with role selection for new users
- ✅ Existing Google users work seamlessly
- ✅ All auth methods support RBAC

### PHASE 8: Dashboard Protection
**GOAL**: Secure dashboards with role guards
**FILES TO MODIFY**: `app/customer-dashboard.tsx`, etc.

```typescript
// Add to each dashboard:
useEffect(() => {
  const checkRole = async () => {
    const role = await getUserRole();
    if (role !== 'customer') { // or appropriate role
      router.replace('/login');
    }
  };
  checkRole();
}, []);
```

**SUCCESS CRITERIA**:
- ✅ Role-based dashboard access
- ✅ Unauthorized users redirected
- ✅ Performance optimized

## IMPLEMENTATION RULES

### DO:
- ✅ Complete each phase 100% before proceeding
- ✅ Test thoroughly after each phase
- ✅ Use .NET API for all WRITE operations
- ✅ Use JWT claims for READ operations
- ✅ Commit after each successful phase
- ✅ Keep existing functionality working

### DON'T:
- ❌ Skip phases or combine them
- ❌ Modify multiple auth flows simultaneously
- ❌ Break existing authentication
- ❌ Put sensitive operations in client
- ❌ Proceed if tests fail

### ENVIRONMENT VARIABLES NEEDED:
```
EXPO_PUBLIC_DOTNET_API_URL=your-dotnet-api-url
EXPO_PUBLIC_DOTNET_API_KEY=your-api-key
```

### ROLLBACK STRATEGY:
- Each phase = separate git commit
- Can rollback to any working phase
- Database migrations are reversible

## VALIDATION CHECKLIST:
After each phase:
- [ ] Existing app functionality works
- [ ] New functionality works as expected
- [ ] No breaking changes introduced
- [ ] Database state is clean
- [ ] Performance acceptable
- [ ] Security requirements met 
